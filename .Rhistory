#
betaprior = matrix(c(c(log(2),log(1e-4),log(1),log(2),log(2)),
c(0.1,0.1,0.1,0.1,0.1)),nrow=5);
sigprior = c(4,2)
phiprior = c(50,10,50,10,50,10,1,1)
y       = as.vector(S)
inputdata1 <- list(
N     = dim(S)[1],
M     = dim(S)[2],
sigprior= sigprior,
phiprior= phiprior,
betaprior=betaprior,
Nnugg    = 1e-6,
Mnugg    = 1e-4,
y       = as.vector(S),
distN    = distNx,
distM    = distMx,
design   = design_norm,
eps      = e,
scaling = scaling,
yscaling = c(ycenter,yscale)
)
init = list('r_betax'=c(log(2),log(0.0001),log(1),log(2.0),log(2)),
'sig2'=0.1,'phi'=c(rep(3,3),0.1))
m1 = stan_model(file='stage1.rstan')
map1 <- optimizing(
object=m1,                              # Stan program
data = inputdata1,                      # named list of data
verbose = T,
as_vector=F,
iter=10000,
#algorithm='Newton',
init=init)
betax   = map1$par$betax
lambda  = map1$par$lambda
phi     = map1$par$phi
mu      = map1$par$mu
sig2      = map1$par$sig2
invCn      = map1$par$inv_Cn
invCm      = map1$par$inv_Cm
logdetCn   = 2*(sum(log(diag(map1$par$LN))))
logdetCm   = 2*(sum(log(diag(map1$par$LM))))
save(list=c('logdetCn','logdetCm','betax','sig2','phi','invCn','invCm','y','mu','S','e','scaling','yscale','ycenter'),
file='stage1_params.RData')
#------------------------------------------------
#    plot NL-regression bit
#------------------------------------------------
rbPal <- colorRampPalette(brewer.pal(dim(design)[1],'YlGnBu'))
sX = sweep(sweep(design_norm,2,scaling[2,1:3]-scaling[1,1:3],'*'),2,scaling[1,1:3],'+')
se = e*(scaling[2,4]-scaling[1,4]) + scaling[1,4]
muhat = (
(sX[,1]%*%t(se)*1e3)**-betax[5]+
(sX[,2]*betax[1]+1e3*betax[4]*sX[,3]%*%t(betax[2]+betax[3]*se))**-betax[5]
)**(-1/betax[5])
png("data_nonlinear_means.png", width=5, height=5, units="in", res=300)
par(mfrow=c(1,1),family='serif')
sD = S*yscale + ycenter
plot(se,sD[1,],ylim=c(0,4000),
xlab=TeX('$\\epsilon$'),ylab=TeX('$\\sigma\\,\\,(MPa)$'),
family="serif",pch=16,col=rbPal(dim(design)[1])[1])
rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4], col = "lightgrey", border = "black")
points(se,sD[1,],ylim=c(0,4000),
xlab=TeX('$\\epsilon$'),ylab=TeX('$\\sigma\\,\\,(MPa)$'),
family="serif",pch=16,col=rbPal(dim(design)[1])[1])
lines(se,muhat[1,],col=rbPal(dim(design)[1])[1])
for (j in 2:dim(design)[1]){
points(se,sD[j,],ylim=c(0,4000),
xlab=TeX('$\\epsilon$'),ylab=TeX('$\\sigma\\,\\,(MPa)$'),
family="serif",pch=16,col=rbPal(dim(design)[1])[j])
lines(se,muhat[j,],col=rbPal(dim(design)[1])[j])
}
dev.off()
###############################################################
#      LEAVE ONE OUT CROSS VALIDATION USING SHORTCUT FORMULA
###############################################################
N = dim(S)[1]
M = dim(S)[2]
Rinv = invCm %x% invCn
#-------------------------------------------
#    mean func
#-------------------------------------------
mean_func = function(x, eps){
# choose to scale things so that the derived betas' have some physical meaning
# and we can interpret them / evaluate them against our intuition
Ehat   = x[1]*(scaling[2,1]-scaling[1,1]) + scaling[1,1];
Yhat   = x[2]*(scaling[2,2]-scaling[1,2]) + scaling[1,2];
Khat   = x[3]*(scaling[2,3]-scaling[1,3]) + scaling[1,3];
epshat   = eps*(scaling[2,4]-scaling[1,4]) + scaling[1,4];
mu = (((epshat*Ehat*1e3)**(-betax[5])) +
(betax[1]*Yhat + betax[4]*Khat*1e3*(betax[2]+betax[3]*epshat))**(-betax[5])
)**(-(1/betax[5]))
return((mu-ycenter)/yscale)
}
#-------------------------------------------
#   map 2&3 computer code predictor
#-------------------------------------------
y_pred =  function(x,eexp){
dstN   = sweep(design_norm,2,x,'-')^2
dstN = dstN %*% diag(phi[1:3])
rtN = exp(-apply(dstN,1,sum))
dstM   = sweep(matrix(rep(e,length(eexp)),nrow=length(e)),2,eexp,'-')^2
rtM = exp(-dstM*phi[4])
#Sighat = sig2*rtM - rtM%x%(t(rtN)%*%invCn%*%rtN)
#      the math for evaluation at one strain
#      yhat = muhat + t(r)*invC*(y-mu)
#      yhat = muhat + t(re %x% rn) * (invCm %x% invCn)*vec(e)
#      yhat = muhat + (t(re) * invCm) %x% (t(rn) * invCn) * vec(e)
#      yhat = muhat + (t(rn)*invCn) * e * (invCm*re)
#
#      can expand for multiple strains and use Re instead of re
#
muhat = c(t(rtN)%*%invCn%*%(matrix(map1$par$err,
nrow=dim(invCn)[1])%*%invCm)%*%rtM)
#muhat = invboxcox(muhat,lambda,gam2)+mean_func(x,eexp)
muhat = muhat+mean_func(x,eexp)
return(list('muhat'=muhat,'Sighat'=0))
}
#-----------------------------------------------
#   map surrogate cross validation estimate
#-----------------------------------------------
cv =  function(){
n = dim(Rinv)[1]
err = invCn %*% (matrix(y,nrow=N,ncol=M)-matrix(mu,nrow=N,ncol=M))
cv = sweep(err,1,diag(invCn),'/')
return(as.vector(cv))
}
Y = y*yscale+ycenter
Y_m_Yhat = cv()
pct = abs(Y_m_Yhat)/Y*100
png("crossval.png", width=8, height=5, units="in", res=300)
par(mfrow=c(1,1),pty="s")
R2 = 1-(sum(Y_m_Yhat**2)/sum((Y-mean(Y))**2))
RMSE = mean(Y_m_Yhat**2)**0.5
plot(Y-Y_m_Yhat,Y,ylim=c(0,2000),xlim=c(0,2000),
main=sprintf('R2=%1.3f RMSPE=%1.1f (MPa)',R2,RMSE),
ylab=bquote(paste(sigma[ind] (MPa))),
xlab=bquote(hat(sigma)[ind] (MPa)))
lines(c(0,2000),c(0,2000),col='red')
dev.off()
ss = function(d,p,a){
strain = (4/3/pi)*d[-1]/a[-1]
stress = p[-1]/pi/a[-1]**2*1e-6
return(list(s=stress,e=strain))
}
files = list.files('LH_u_ofhc_cons_2','[0-9]_output.txt')
files = files[order(as.numeric(gsub("[^0-9]+","",files)))] # get files ordered relative to design pnts
f = files[1]
x = as.matrix(read.csv(paste('LH_u_ofhc_cons_2\\',f,sep=''),header=FALSE,sep=","));
out = ss(x[,3],x[,2],x[,4])
E2 = matrix(0,length(files),length(out$e))
S2 = matrix(0,length(files),length(out$e))
E2[1,]=out$e
S2[1,]=out$s
count=1
for (f in files[-1]){
count=count+1
x = as.matrix(read.csv(paste('LH_u_ofhc_cons_2\\',f,sep=''),header=FALSE,sep=","));
out = ss(x[,3],x[,2],x[,4])
E2[count,]=out$e
S2[count,]=out$s
}
inds = as.integer(gsub("[^0-9]+","",files))
design2  = as.matrix(read.csv("LH_u_ofhc_cons_2\\n50d3.txt",header=FALSE,sep=","))[inds,];
scaling2 = scaling
# map the design to 0-1
inds = which(design2[,1]>design2[,3])
design2 = sweep(sweep(design2,2,scaling[1,seq(1,3)],'-'),2,
scaling[2,seq(1,3)]-scaling[1,seq(1,3)],'/')
design2=design2[inds,]
E2=E2[inds,]
S2=S2[inds,]
inds = which(apply(design2,1,min)>0.0 & apply(design2,1,max)<1.0)
design2=design2[inds,]
E2=(E2[inds,]-ecenter)/escale
S2=S2[inds,]
E2=E2[,seq(2,58)]
S2=S2[,seq(2,58)]
Sp = S2
for (i in 1:nrow(design2)){
Sp[i,] = y_pred(design2[i,],E2[i,])$muhat*yscale + ycenter
}
#png("val.png", width=8, height=5, units="in", res=300)
par(mfrow=c(2,2),pty="s")
R2 = 1-(sum((S2-Sp)**2)/sum((S2-mean(S2))**2))
RMSE = mean((S2-Sp)**2)**0.5
plot(Sp,S2,ylim=c(0,4000),xlim=c(0,4000),
main=sprintf('R2=%1.3f RMSPE=%1.1f (MPa)',R2,RMSE),
ylab=bquote(paste(sigma[ind] (MPa))),
xlab=bquote(hat(sigma)[ind] (MPa)))
lines(c(0,4000),c(0,4000),col='red')
#dev.off()
Sp = S2
for (i in 1:nrow(design2)){
Sp[i,] = mean_func(design2[i,],E2[i,])*yscale + ycenter
}
#png("val.png", width=8, height=5, units="in", res=300)
R2 = 1-(sum((S2-Sp)**2)/sum((S2-mean(S2))**2))
RMSE = mean((S2-Sp)**2)**0.5
plot(Sp,S2,ylim=c(0,4000),xlim=c(0,4000),
main=sprintf('R2=%1.3f RMSPE=%1.1f (MPa)',R2,RMSE),
ylab=bquote(paste(sigma[ind] (MPa))),
xlab=bquote(hat(sigma)[ind] (MPa)))
lines(c(0,4000),c(0,4000),col='red')
#dev.off()
Sp = S
for (i in 1:nrow(design_norm)){
Sp[i,] = y_pred(design_norm[i,],e)$muhat*yscale + ycenter
}
#png("val.png", width=8, height=5, units="in", res=300)
R2 = 1-(sum((S*yscale+ycenter-Sp)**2)/sum((S*yscale+ycenter-mean(S*yscale+ycenter))**2))
RMSE = mean((S*yscale+ycenter-Sp)**2)**0.5
plot(Sp,S*yscale+ycenter,ylim=c(0,4000),xlim=c(0,4000),
main=sprintf('R2=%1.3f RMSPE=%1.1f (MPa)',R2,RMSE),
ylab=bquote(paste(sigma[ind] (MPa))),
xlab=bquote(hat(sigma)[ind] (MPa)))
lines(c(0,4000),c(0,4000),col='red')
#dev.off()
Sp = S
for (i in 1:nrow(design_norm)){
Sp[i,] = mean_func(design_norm[i,],e)*yscale + ycenter
}
#png("val.png", width=8, height=5, units="in", res=300)
R2 = 1-(sum((S*yscale+ycenter-Sp)**2)/sum((S*yscale+ycenter-mean(S*yscale+ycenter))**2))
RMSE = mean((S*yscale+ycenter-Sp)**2)**0.5
plot(Sp,S*yscale+ycenter,ylim=c(0,4000),xlim=c(0,4000),
main=sprintf('R2=%1.3f RMSPE=%1.1f (MPa)',R2,RMSE),
ylab=bquote(paste(sigma[ind] (MPa))),
xlab=bquote(hat(sigma)[ind] (MPa)))
lines(c(0,4000),c(0,4000),col='red')
#dev.off()
ss = function(d,p,a){
strain = (4/3/pi)*d[-1]/a[-1]
stress = p[-1]/pi/a[-1]**2*1e-6
return(list(s=stress,e=strain))
}
files = list.files('LH_u_ofhc_cons_2','[0-9]_output.txt')
files = files[order(as.numeric(gsub("[^0-9]+","",files)))] # get files ordered relative to design pnts
f = files[1]
x = as.matrix(read.csv(paste('LH_u_ofhc_cons_2\\',f,sep=''),header=FALSE,sep=","));
out = ss(x[,3],x[,2],x[,4])
E2 = matrix(0,length(files),length(out$e))
S2 = matrix(0,length(files),length(out$e))
E2[1,]=out$e
S2[1,]=out$s
count=1
for (f in files[-1]){
count=count+1
x = as.matrix(read.csv(paste('LH_u_ofhc_cons_2\\',f,sep=''),header=FALSE,sep=","));
out = ss(x[,3],x[,2],x[,4])
E2[count,]=out$e
S2[count,]=out$s
}
inds = as.integer(gsub("[^0-9]+","",files))
design2  = as.matrix(read.csv("LH_u_ofhc_cons_2\\n50d3.txt",header=FALSE,sep=","))[inds,];
scaling2 = scaling
# map the design to 0-1
inds = which(design2[,1]>design2[,3])
design2 = sweep(sweep(design2,2,scaling[1,seq(1,3)],'-'),2,
scaling[2,seq(1,3)]-scaling[1,seq(1,3)],'/')
design2=design2[inds,]
E2=E2[inds,]
S2=S2[inds,]
inds = which(apply(design2,1,min)>0.0 & apply(design2,1,max)<1.0)
design2=design2[inds,]
E2=(E2[inds,]-ecenter)/escale
S2=S2[inds,]
E2=E2[,seq(2,58)]
S2=S2[,seq(2,58)]
Sp = S2
for (i in 1:nrow(design2)){
Sp[i,] = y_pred(design2[i,],E2[i,])$muhat*yscale + ycenter
}
#png("val.png", width=8, height=5, units="in", res=300)
par(mfrow=c(1,2),pty="s")
R2 = 1-(sum((S2-Sp)**2)/sum((S2-mean(S2))**2))
RMSE = mean((S2-Sp)**2)**0.5
plot(Sp,S2,ylim=c(0,4000),xlim=c(0,4000),
main=sprintf('R2=%1.3f\nRMSPE=%1.1f (MPa)',R2,RMSE),
ylab=bquote(paste(sigma[ind] (MPa))),
xlab=bquote(hat(sigma)[ind] (MPa)))
lines(c(0,4000),c(0,4000),col='red')
#dev.off()
Sp = S2
for (i in 1:nrow(design2)){
Sp[i,] = mean_func(design2[i,],E2[i,])*yscale + ycenter
}
#png("val.png", width=8, height=5, units="in", res=300)
R2 = 1-(sum((S2-Sp)**2)/sum((S2-mean(S2))**2))
RMSE = mean((S2-Sp)**2)**0.5
plot(Sp,S2,ylim=c(0,4000),xlim=c(0,4000),
main=sprintf('R2=%1.3f\nRMSPE=%1.1f (MPa)',R2,RMSE),
ylab=bquote(paste(sigma[ind] (MPa))),
xlab=bquote(hat(sigma)[ind] (MPa)))
lines(c(0,4000),c(0,4000),col='red')
#dev.off()
#png("val.png", width=8, height=5, units="in", res=300)
par(mfrow=c(1,2),pty="s")
R2 = 1-(sum((S2-Sp)**2)/sum((S2-mean(S2))**2))
RMSE = mean((S2-Sp)**2)**0.5
plot(Sp,S2,ylim=c(0,4000),xlim=c(0,4000),
main=sprintf('Mean function\nR2=%1.3f\nRMSPE=%1.1f (MPa)',R2,RMSE),
ylab=bquote(paste(sigma[ind] (MPa))),
xlab=bquote(hat(sigma)[ind] (MPa)))
lines(c(0,4000),c(0,4000),col='red')
#dev.off()
Sp = S2
for (i in 1:nrow(design2)){
Sp[i,] = mean_func(design2[i,],E2[i,])*yscale + ycenter
}
#png("val.png", width=8, height=5, units="in", res=300)
R2 = 1-(sum((S2-Sp)**2)/sum((S2-mean(S2))**2))
RMSE = mean((S2-Sp)**2)**0.5
plot(Sp,S2,ylim=c(0,4000),xlim=c(0,4000),
main=sprintf('GP surrogate\nR2=%1.3f\nRMSPE=%1.1f (MPa)',R2,RMSE),
ylab=bquote(paste(sigma[ind] (MPa))),
xlab=bquote(hat(sigma)[ind] (MPa)))
lines(c(0,4000),c(0,4000),col='red')
#dev.off()
ss = function(d,p,a){
strain = (4/3/pi)*d[-1]/a[-1]
stress = p[-1]/pi/a[-1]**2*1e-6
return(list(s=stress,e=strain))
}
files = list.files('LH_u_ofhc_cons_2','[0-9]_output.txt')
files = files[order(as.numeric(gsub("[^0-9]+","",files)))] # get files ordered relative to design pnts
f = files[1]
x = as.matrix(read.csv(paste('LH_u_ofhc_cons_2\\',f,sep=''),header=FALSE,sep=","));
out = ss(x[,3],x[,2],x[,4])
E2 = matrix(0,length(files),length(out$e))
S2 = matrix(0,length(files),length(out$e))
E2[1,]=out$e
S2[1,]=out$s
count=1
for (f in files[-1]){
count=count+1
x = as.matrix(read.csv(paste('LH_u_ofhc_cons_2\\',f,sep=''),header=FALSE,sep=","));
out = ss(x[,3],x[,2],x[,4])
E2[count,]=out$e
S2[count,]=out$s
}
inds = as.integer(gsub("[^0-9]+","",files))
design2  = as.matrix(read.csv("LH_u_ofhc_cons_2\\n50d3.txt",header=FALSE,sep=","))[inds,];
scaling2 = scaling
# map the design to 0-1
inds = which(design2[,1]>design2[,3])
design2 = sweep(sweep(design2,2,scaling[1,seq(1,3)],'-'),2,
scaling[2,seq(1,3)]-scaling[1,seq(1,3)],'/')
design2=design2[inds,]
E2=E2[inds,]
S2=S2[inds,]
inds = which(apply(design2,1,min)>0.0 & apply(design2,1,max)<1.0)
design2=design2[inds,]
E2=(E2[inds,]-ecenter)/escale
S2=S2[inds,]
E2=E2[,seq(2,58)]
S2=S2[,seq(2,58)]
Sp = S2
for (i in 1:nrow(design2)){
Sp[i,] = y_pred(design2[i,],E2[i,])$muhat*yscale + ycenter
}
#png("val.png", width=8, height=5, units="in", res=300)
par(mfrow=c(1,2),pty="s")
R2 = 1-(sum((S2-Sp)**2)/sum((S2-mean(S2))**2))
RMSE = mean((S2-Sp)**2)**0.5
plot(Sp,S2,ylim=c(0,4000),xlim=c(0,4000),
main=sprintf('Mean function\nR2=%1.3f\nRMSPE=%1.1f (MPa)',R2,RMSE),
ylab=bquote(paste(sigma[ind] (MPa))),
xlab=bquote(hat(sigma)[ind] (MPa)))
lines(c(0,4000),c(0,4000),col='red')
#dev.off()
Sp = S2
for (i in 1:nrow(design2)){
Sp[i,] = mean_func(design2[i,],E2[i,])*yscale + ycenter
}
#png("val.png", width=8, height=5, units="in", res=300)
R2 = 1-(sum((S2-Sp)**2)/sum((S2-mean(S2))**2))
RMSE = mean((S2-Sp)**2)**0.5
plot(Sp,S2,ylim=c(0,4000),xlim=c(0,4000),
main=sprintf('GP surrogate\nR2=%1.3f\nRMSPE=%1.1f (MPa)',R2,RMSE),
ylab=bquote(paste(sigma[ind] (MPa))),
xlab=bquote(hat(sigma)[ind] (MPa)))
lines(c(0,4000),c(0,4000),col='red')
#dev.off()
ss = function(d,p,a){
strain = (4/3/pi)*d[-1]/a[-1]
stress = p[-1]/pi/a[-1]**2*1e-6
return(list(s=stress,e=strain))
}
files = list.files('LH_u_ofhc_cons_2','[0-9]_output.txt')
files = files[order(as.numeric(gsub("[^0-9]+","",files)))] # get files ordered relative to design pnts
f = files[1]
x = as.matrix(read.csv(paste('LH_u_ofhc_cons_2\\',f,sep=''),header=FALSE,sep=","));
out = ss(x[,3],x[,2],x[,4])
E2 = matrix(0,length(files),length(out$e))
S2 = matrix(0,length(files),length(out$e))
E2[1,]=out$e
S2[1,]=out$s
count=1
for (f in files[-1]){
count=count+1
x = as.matrix(read.csv(paste('LH_u_ofhc_cons_2\\',f,sep=''),header=FALSE,sep=","));
out = ss(x[,3],x[,2],x[,4])
E2[count,]=out$e
S2[count,]=out$s
}
inds = as.integer(gsub("[^0-9]+","",files))
design2  = as.matrix(read.csv("LH_u_ofhc_cons_2\\n50d3.txt",header=FALSE,sep=","))[inds,];
scaling2 = scaling
# map the design to 0-1
inds = which(design2[,1]>design2[,3])
design2 = sweep(sweep(design2,2,scaling[1,seq(1,3)],'-'),2,
scaling[2,seq(1,3)]-scaling[1,seq(1,3)],'/')
design2=design2[inds,]
E2=E2[inds,]
S2=S2[inds,]
inds = which(apply(design2,1,min)>0.0 & apply(design2,1,max)<1.0)
design2=design2[inds,]
E2=(E2[inds,]-ecenter)/escale
S2=S2[inds,]
E2=E2[,seq(2,58)]
S2=S2[,seq(2,58)]
Sp = S2
for (i in 1:nrow(design2)){
Sp[i,] = y_pred(design2[i,],E2[i,])$muhat*yscale + ycenter
}
#png("val.png", width=8, height=5, units="in", res=300)
par(mfrow=c(1,2),pty="s")
R2 = 1-(sum((S2-Sp)**2)/sum((S2-mean(S2))**2))
RMSE = mean((S2-Sp)**2)**0.5
plot(Sp,S2,ylim=c(0,4000),xlim=c(0,4000),
main=sprintf('GP surrogate\nR2=%1.3f\nRMSPE=%1.1f (MPa)',R2,RMSE),
ylab=bquote(paste(sigma[ind] (MPa))),
xlab=bquote(hat(sigma)[ind] (MPa)))
lines(c(0,4000),c(0,4000),col='red')
#dev.off()
Sp = S2
for (i in 1:nrow(design2)){
Sp[i,] = mean_func(design2[i,],E2[i,])*yscale + ycenter
}
#png("val.png", width=8, height=5, units="in", res=300)
R2 = 1-(sum((S2-Sp)**2)/sum((S2-mean(S2))**2))
RMSE = mean((S2-Sp)**2)**0.5
plot(Sp,S2,ylim=c(0,4000),xlim=c(0,4000),
main=sprintf('Mean function\nR2=%1.3f\nRMSPE=%1.1f (MPa)',R2,RMSE),
ylab=bquote(paste(sigma[ind] (MPa))),
xlab=bquote(hat(sigma)[ind] (MPa)))
lines(c(0,4000),c(0,4000),col='red')
#dev.off()
ss = function(d,p,a){
strain = (4/3/pi)*d[-1]/a[-1]
stress = p[-1]/pi/a[-1]**2*1e-6
return(list(s=stress,e=strain))
}
files = list.files('LH_u_ofhc_cons_2','[0-9]_output.txt')
files = files[order(as.numeric(gsub("[^0-9]+","",files)))] # get files ordered relative to design pnts
f = files[1]
x = as.matrix(read.csv(paste('LH_u_ofhc_cons_2\\',f,sep=''),header=FALSE,sep=","));
out = ss(x[,3],x[,2],x[,4])
E2 = matrix(0,length(files),length(out$e))
S2 = matrix(0,length(files),length(out$e))
E2[1,]=out$e
S2[1,]=out$s
count=1
for (f in files[-1]){
count=count+1
x = as.matrix(read.csv(paste('LH_u_ofhc_cons_2\\',f,sep=''),header=FALSE,sep=","));
out = ss(x[,3],x[,2],x[,4])
E2[count,]=out$e
S2[count,]=out$s
}
inds = as.integer(gsub("[^0-9]+","",files))
design2  = as.matrix(read.csv("LH_u_ofhc_cons_2\\n50d3.txt",header=FALSE,sep=","))[inds,];
scaling2 = scaling
# map the design to 0-1
inds = which(design2[,1]>design2[,3])
design2 = sweep(sweep(design2,2,scaling[1,seq(1,3)],'-'),2,
scaling[2,seq(1,3)]-scaling[1,seq(1,3)],'/')
design2=design2[inds,]
E2=E2[inds,]
S2=S2[inds,]
inds = which(apply(design2,1,min)>0.0 & apply(design2,1,max)<1.0)
design2=design2[inds,]
E2=(E2[inds,]-ecenter)/escale
S2=S2[inds,]
E2=E2[,seq(2,58)]
S2=S2[,seq(2,58)]
Sp = S2
for (i in 1:nrow(design2)){
Sp[i,] = y_pred(design2[i,],E2[i,])$muhat*yscale + ycenter
}
png("val.png", width=8, height=5, units="in", res=300)
par(mfrow=c(1,2),pty="s")
R2 = 1-(sum((S2-Sp)**2)/sum((S2-mean(S2))**2))
RMSE = mean((S2-Sp)**2)**0.5
plot(Sp,S2,ylim=c(0,4000),xlim=c(0,4000),
main=sprintf('GP surrogate\nR2=%1.3f\nRMSPE=%1.1f (MPa)',R2,RMSE),
ylab=bquote(paste(sigma[ind] (MPa))),
xlab=bquote(hat(sigma)[ind] (MPa)))
lines(c(0,4000),c(0,4000),col='red')
#dev.off()
Sp = S2
for (i in 1:nrow(design2)){
Sp[i,] = mean_func(design2[i,],E2[i,])*yscale + ycenter
}
R2 = 1-(sum((S2-Sp)**2)/sum((S2-mean(S2))**2))
RMSE = mean((S2-Sp)**2)**0.5
plot(Sp,S2,ylim=c(0,4000),xlim=c(0,4000),
main=sprintf('Mean function\nR2=%1.3f\nRMSPE=%1.1f (MPa)',R2,RMSE),
ylab=bquote(paste(sigma[ind] (MPa))),
xlab=bquote(hat(sigma)[ind] (MPa)))
lines(c(0,4000),c(0,4000),col='red')
dev.off()
